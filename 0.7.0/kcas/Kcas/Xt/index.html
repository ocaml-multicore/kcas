<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml"><head><title>Xt (kcas.Kcas.Xt)</title><meta charset="utf-8"/><link rel="stylesheet" href="../../../odoc.support/odoc.css"/><meta name="generator" content="odoc 2.4.1"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><script src="../../../odoc.support/highlight.pack.js"></script><script>hljs.initHighlightingOnLoad();</script><script>let base_url = '../../../';
let search_urls = ['../../db.js','../../../sherlodoc.js'];
</script><script src="../../../odoc.support/odoc_search.js" defer="defer"></script></head><body class="odoc"><nav class="odoc-nav"><a href="../index.html">Up</a> â€“ <a href="../../index.html">kcas</a> &#x00BB; <a href="../index.html">Kcas</a> &#x00BB; Xt</nav><div class="odoc-search"><div class="search-inner"><input class="search-bar" placeholder="ðŸ”Ž Search..."/><div class="search-snake"></div><div class="search-result"></div></div></div><header class="odoc-preamble"><h1>Module <code><span>Kcas.Xt</span></code></h1><p>Explicit transaction log passing on shared memory locations.</p><p>This module provides a way to implement composable transactions over shared memory locations. A transaction is a function written by the library user and can be thought of as a specification of a sequence of <a href="#val-get"><code>Xt.get</code></a> and <a href="#val-set"><code>Xt.set</code></a> accesses to shared memory locations. To actually perform the accesses one then <a href="#val-commit"><code>Xt.commit</code></a>s the transaction.</p><p>Transactions should generally not perform arbitrary side-effects, because when a transaction is committed it may be attempted multiple times meaning that the side-effects are also performed multiple times. <a href="#val-post_commit"><code>Xt.post_commit</code></a> can be used to perform an action only once after the transaction has been committed succesfully.</p><p><b>WARNING</b>: To make it clear, the operations provided by the <a href="../Loc/index.html"><code>Loc</code></a> module for accessing individual shared memory locations do not implicitly go through the transaction mechanism and should generally not be used within transactions. There are advanced algorithms where one might, within a transaction, perform operations that do not get recorded into the transaction log. Using such techniques correctly requires expert knowledge and is not recommended for casual users.</p><p>As an example, consider an implementation of doubly-linked circular lists. Instead of using a mutable field, <code>ref</code>, or <code>Atomic.t</code>, one would use a shared memory location, or <a href="../Loc/index.html#type-t"><code>Loc.t</code></a>, for the pointers in the node type:</p><pre class="language-ocaml"><code>type 'a node = {
  succ: 'a node Loc.t;
  pred: 'a node Loc.t;
  datum: 'a;
}</code></pre><p>To remove a node safely one wants to atomically update the <code>succ</code> and <code>pred</code> pointers of the predecessor and successor nodes and to also update the <code>succ</code> and <code>pred</code> pointers of a node to point to the node itself, so that removal becomes an <a href="https://en.wikipedia.org/wiki/Idempotence">idempotent</a> operation. Using explicit transaction log passing one could implement the <code>remove</code> operation as follows:</p><pre class="language-ocaml"><code>let remove ~xt node =
  (* Read pointers to the predecessor and successor nodes: *)
  let pred = Xt.get ~xt node.pred in
  let succ = Xt.get ~xt node.succ in
  (* Update pointers in this node: *)
  Xt.set ~xt node.succ node;
  Xt.set ~xt node.pred node;
  (* Update pointers to this node: *)
  Xt.set ~xt pred.succ succ;
  Xt.set ~xt succ.pred pred</code></pre><p>The labeled argument, <code>~xt</code>, refers to the transaction log. Transactional operations like <a href="#val-get"><code>Xt.get</code></a> and <a href="#val-set"><code>Xt.set</code></a> are then recorded in that log. To actually remove a node, we need to commit the transaction</p><pre class="language-ocaml"><code>Xt.commit { tx = remove node }</code></pre><p>which repeatedly calls the transaction function, <code>tx</code>, to record a transaction log and attempts to atomically perform it until it succeeds.</p><p>Notice that <code>remove</code> is not recursive. It doesn't have to account for failure or perform a backoff. It is also not necessary to know or keep track of what the previous values of locations were. All of that is taken care of for us by the transaction log and the <a href="#val-commit"><code>Xt.commit</code></a> function. Furthermore, <code>remove</code> can easily be called as a part of a more complex transaction.</p></header><nav class="odoc-toc"><ul><li><a href="#recording-accesses">Recording accesses</a></li><li><a href="#blocking">Blocking</a></li><li><a href="#nested-transactions">Nested transactions</a></li><li><a href="#post-commit-actions">Post commit actions</a></li><li><a href="#validation">Validation</a></li><li><a href="#advanced">Advanced</a></li><li><a href="#performing-accesses">Performing accesses</a></li></ul></nav><div class="odoc-content"><div class="odoc-spec"><div class="spec type anchored" id="type-t"><a href="#type-t" class="anchor"></a><code><span><span class="keyword">type</span> <span>'x t</span></span></code></div><div class="spec-doc"><p>Type of an explicit transaction log on shared memory locations.</p><p>Note that a transaction log itself is not safe against concurrent or parallel use and should generally only be used by a single thread of execution. If a new thread of execution is spawned inside a function recording shared memory accesses to a log and the new thread of execution also records accesses to the log it may become inconsistent.</p></div></div><h2 id="recording-accesses"><a href="#recording-accesses" class="anchor"></a>Recording accesses</h2><p>Accesses of shared memory locations using an explicit transaction log first ensure that the initial value of the shared memory location is recorded in the log and then act on the current value of the shared memory location as recorded in the log.</p><p>It is important to understand that it is possible for a transaction to observe the contents of two (or more) different shared memory locations from two (or more) different committed updates. This means that invariants that hold between two (or more) different shared memory locations may be seen as broken inside the transaction function. However, it is not possible for the transaction attempt to succeed after it has seen such an inconsistent view of the shared memory locations.</p><p>To mitigate potential issues due to this read skew anomaly and due to very long running transactions, all of the access recording operations in this section periodically validate the entire transaction log when a previously accessed location is accessed again. An important guideline for writing transactions is that loops inside a transaction should always include an access of some shared memory location through the transaction log or should otherwise be guaranteed to be bounded.</p><div class="odoc-spec"><div class="spec value anchored" id="val-get"><a href="#val-get" class="anchor"></a><code><span><span class="keyword">val</span> get : <span><span class="label">xt</span>:<span><span class="type-var">'x</span> <a href="#type-t">t</a></span> <span class="arrow">&#45;&gt;</span></span> <span><span><span class="type-var">'a</span> <a href="../Loc/index.html#type-t">Loc.t</a></span> <span class="arrow">&#45;&gt;</span></span> <span class="type-var">'a</span></span></code></div><div class="spec-doc"><p><code>get ~xt r</code> returns the current value of the shared memory location <code>r</code> in the explicit transaction log <code>xt</code>.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-set"><a href="#val-set" class="anchor"></a><code><span><span class="keyword">val</span> set : <span><span class="label">xt</span>:<span><span class="type-var">'x</span> <a href="#type-t">t</a></span> <span class="arrow">&#45;&gt;</span></span> <span><span><span class="type-var">'a</span> <a href="../Loc/index.html#type-t">Loc.t</a></span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'a</span> <span class="arrow">&#45;&gt;</span></span> unit</span></code></div><div class="spec-doc"><p><code>set ~xt r v</code> records the current value of the shared memory location <code>r</code> to be the given value <code>v</code> in the explicit transaction log <code>xt</code>.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-update"><a href="#val-update" class="anchor"></a><code><span><span class="keyword">val</span> update : <span><span class="label">xt</span>:<span><span class="type-var">'x</span> <a href="#type-t">t</a></span> <span class="arrow">&#45;&gt;</span></span> <span><span><span class="type-var">'a</span> <a href="../Loc/index.html#type-t">Loc.t</a></span> <span class="arrow">&#45;&gt;</span></span> <span><span>(<span><span class="type-var">'a</span> <span class="arrow">&#45;&gt;</span></span> <span class="type-var">'a</span>)</span> <span class="arrow">&#45;&gt;</span></span> <span class="type-var">'a</span></span></code></div><div class="spec-doc"><p><code>update ~xt r f</code> is equivalent to <code>let x = get ~xt r in set ~xt r (f x); x</code> with the limitation that <code>f</code> must not and is not allowed to access the transaction log.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-modify"><a href="#val-modify" class="anchor"></a><code><span><span class="keyword">val</span> modify : <span><span class="label">xt</span>:<span><span class="type-var">'x</span> <a href="#type-t">t</a></span> <span class="arrow">&#45;&gt;</span></span> <span><span><span class="type-var">'a</span> <a href="../Loc/index.html#type-t">Loc.t</a></span> <span class="arrow">&#45;&gt;</span></span> <span><span>(<span><span class="type-var">'a</span> <span class="arrow">&#45;&gt;</span></span> <span class="type-var">'a</span>)</span> <span class="arrow">&#45;&gt;</span></span> unit</span></code></div><div class="spec-doc"><p><code>modify ~xt r f</code> is equivalent to <code>let x = get ~xt r in set ~xt r (f x)</code> with the limitation that <code>f</code> must not and is not allowed to access the transaction log.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-exchange"><a href="#val-exchange" class="anchor"></a><code><span><span class="keyword">val</span> exchange : <span><span class="label">xt</span>:<span><span class="type-var">'x</span> <a href="#type-t">t</a></span> <span class="arrow">&#45;&gt;</span></span> <span><span><span class="type-var">'a</span> <a href="../Loc/index.html#type-t">Loc.t</a></span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'a</span> <span class="arrow">&#45;&gt;</span></span> <span class="type-var">'a</span></span></code></div><div class="spec-doc"><p><code>exchange ~xt r v</code> is equivalent to <code>update ~xt r (fun _ -&gt; v)</code>.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-swap"><a href="#val-swap" class="anchor"></a><code><span><span class="keyword">val</span> swap : <span><span class="label">xt</span>:<span><span class="type-var">'x</span> <a href="#type-t">t</a></span> <span class="arrow">&#45;&gt;</span></span> <span><span><span class="type-var">'a</span> <a href="../Loc/index.html#type-t">Loc.t</a></span> <span class="arrow">&#45;&gt;</span></span> <span><span><span class="type-var">'a</span> <a href="../Loc/index.html#type-t">Loc.t</a></span> <span class="arrow">&#45;&gt;</span></span> unit</span></code></div><div class="spec-doc"><p><code>swap ~xt l1 l2</code> is equivalent to <code>set ~xt l1 @@ exchange ~xt l2 @@ get ~xt l1</code>.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-compare_and_set"><a href="#val-compare_and_set" class="anchor"></a><code><span><span class="keyword">val</span> compare_and_set : <span><span class="label">xt</span>:<span><span class="type-var">'x</span> <a href="#type-t">t</a></span> <span class="arrow">&#45;&gt;</span></span> <span><span><span class="type-var">'a</span> <a href="../Loc/index.html#type-t">Loc.t</a></span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'a</span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'a</span> <span class="arrow">&#45;&gt;</span></span> bool</span></code></div><div class="spec-doc"><p><code>compare_and_set ~xt r before after</code> is equivalent to <code>compare_and_swap ~xt r before after == before</code>.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-compare_and_swap"><a href="#val-compare_and_swap" class="anchor"></a><code><span><span class="keyword">val</span> compare_and_swap : <span><span class="label">xt</span>:<span><span class="type-var">'x</span> <a href="#type-t">t</a></span> <span class="arrow">&#45;&gt;</span></span> <span><span><span class="type-var">'a</span> <a href="../Loc/index.html#type-t">Loc.t</a></span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'a</span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'a</span> <span class="arrow">&#45;&gt;</span></span> <span class="type-var">'a</span></span></code></div><div class="spec-doc"><p><code>compare_and_swap ~xt r before after</code> is equivalent to</p><pre class="language-ocaml"><code>update ~xt r @@ fun actual -&gt;
if actual == before then after else actual</code></pre></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-fetch_and_add"><a href="#val-fetch_and_add" class="anchor"></a><code><span><span class="keyword">val</span> fetch_and_add : <span><span class="label">xt</span>:<span><span class="type-var">'x</span> <a href="#type-t">t</a></span> <span class="arrow">&#45;&gt;</span></span> <span><span>int <a href="../Loc/index.html#type-t">Loc.t</a></span> <span class="arrow">&#45;&gt;</span></span> <span>int <span class="arrow">&#45;&gt;</span></span> int</span></code></div><div class="spec-doc"><p><code>fetch_and_add ~xt r n</code> is equivalent to <code>update ~xt r ((+) n)</code>.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-incr"><a href="#val-incr" class="anchor"></a><code><span><span class="keyword">val</span> incr : <span><span class="label">xt</span>:<span><span class="type-var">'x</span> <a href="#type-t">t</a></span> <span class="arrow">&#45;&gt;</span></span> <span><span>int <a href="../Loc/index.html#type-t">Loc.t</a></span> <span class="arrow">&#45;&gt;</span></span> unit</span></code></div><div class="spec-doc"><p><code>incr ~xt r</code> is equivalent to <code>fetch_and_add ~xt r 1 |&gt; ignore</code>.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-decr"><a href="#val-decr" class="anchor"></a><code><span><span class="keyword">val</span> decr : <span><span class="label">xt</span>:<span><span class="type-var">'x</span> <a href="#type-t">t</a></span> <span class="arrow">&#45;&gt;</span></span> <span><span>int <a href="../Loc/index.html#type-t">Loc.t</a></span> <span class="arrow">&#45;&gt;</span></span> unit</span></code></div><div class="spec-doc"><p><code>decr ~xt r</code> is equivalent to <code>fetch_and_add ~xt r (-1) |&gt; ignore</code>.</p></div></div><h2 id="blocking"><a href="#blocking" class="anchor"></a>Blocking</h2><div class="odoc-spec"><div class="spec value anchored" id="val-to_blocking"><a href="#val-to_blocking" class="anchor"></a><code><span><span class="keyword">val</span> to_blocking : <span><span class="label">xt</span>:<span><span class="type-var">'x</span> <a href="#type-t">t</a></span> <span class="arrow">&#45;&gt;</span></span> <span><span>(<span><span class="label">xt</span>:<span><span class="type-var">'x</span> <a href="#type-t">t</a></span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'a</span> option</span>)</span> <span class="arrow">&#45;&gt;</span></span> <span class="type-var">'a</span></span></code></div><div class="spec-doc"><p><code>to_blocking ~xt tx</code> converts the non-blocking transaction <code>tx</code> to a blocking transaction by retrying on <code>None</code>.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-to_nonblocking"><a href="#val-to_nonblocking" class="anchor"></a><code><span><span class="keyword">val</span> to_nonblocking : <span><span class="label">xt</span>:<span><span class="type-var">'x</span> <a href="#type-t">t</a></span> <span class="arrow">&#45;&gt;</span></span> <span><span>(<span><span class="label">xt</span>:<span><span class="type-var">'x</span> <a href="#type-t">t</a></span> <span class="arrow">&#45;&gt;</span></span> <span class="type-var">'a</span>)</span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'a</span> option</span></span></code></div><div class="spec-doc"><p><code>to_nonblocking ~xt tx</code> converts the blocking transaction <code>tx</code> to a non-blocking transaction by returning <code>None</code> on retry.</p></div></div><h2 id="nested-transactions"><a href="#nested-transactions" class="anchor"></a>Nested transactions</h2><p>The transaction mechanism does not implicitly rollback changes recorded in the transaction log. Using <a href="#val-snapshot"><code>snapshot</code></a> and <a href="#val-rollback"><code>rollback</code></a> it is possible to implement nested conditional transactions that may tentatively record changes in the transaction log and then later discard those changes.</p><div class="odoc-spec"><div class="spec type anchored" id="type-snap"><a href="#type-snap" class="anchor"></a><code><span><span class="keyword">type</span> <span>'x snap</span></span></code></div><div class="spec-doc"><p>Type of a <a href="#val-snapshot"><code>snapshot</code></a> of a transaction log.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-snapshot"><a href="#val-snapshot" class="anchor"></a><code><span><span class="keyword">val</span> snapshot : <span><span class="label">xt</span>:<span><span class="type-var">'x</span> <a href="#type-t">t</a></span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'x</span> <a href="#type-snap">snap</a></span></span></code></div><div class="spec-doc"><p><code>snapshot ~xt</code> returns a snapshot of the transaction log.</p><p>Taking a snapshot is a fast constant time <code>O(1)</code> operation.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-rollback"><a href="#val-rollback" class="anchor"></a><code><span><span class="keyword">val</span> rollback : <span><span class="label">xt</span>:<span><span class="type-var">'x</span> <a href="#type-t">t</a></span> <span class="arrow">&#45;&gt;</span></span> <span><span><span class="type-var">'x</span> <a href="#type-snap">snap</a></span> <span class="arrow">&#45;&gt;</span></span> unit</span></code></div><div class="spec-doc"><p><code>rollback ~xt snap</code> discards any changes of shared memory locations recorded in the transaction log after the <code>snap</code> was taken by <a href="#val-snapshot"><code>snapshot</code></a>.</p><p>Performing a rollback is potentially as expensive as linear time <code>O(n)</code> in the number of locations accessed, but, depending on the exact access patterns, may also be performed more quickly. The implementation is optimized with the assumption that a rollback is performed at most once per snapshot.</p><p><b>NOTE</b>: Only changes are discarded. Any location newly accessed after the snapshot was taken will remain recorded in the log as a read-only entry.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-first"><a href="#val-first" class="anchor"></a><code><span><span class="keyword">val</span> first : <span><span class="label">xt</span>:<span><span class="type-var">'x</span> <a href="#type-t">t</a></span> <span class="arrow">&#45;&gt;</span></span> <span><span><span>(<span><span class="label">xt</span>:<span><span class="type-var">'x</span> <a href="#type-t">t</a></span> <span class="arrow">&#45;&gt;</span></span> <span class="type-var">'a</span>)</span> list</span> <span class="arrow">&#45;&gt;</span></span> <span class="type-var">'a</span></span></code></div><div class="spec-doc"><p><code>first ~xt txs</code> calls each transaction in the given list in turn and either returns the value returned by the first transaction in the list or raises <a href="../Retry/index.html#exception-Later"><code>Retry.Later</code></a> in case all of the transactions raised <a href="../Retry/index.html#exception-Later"><code>Retry.Later</code></a>.</p><p><b>NOTE</b>: <code>first</code> does not automatically rollback changes made by the transactions.</p></div></div><h2 id="post-commit-actions"><a href="#post-commit-actions" class="anchor"></a>Post commit actions</h2><div class="odoc-spec"><div class="spec value anchored" id="val-post_commit"><a href="#val-post_commit" class="anchor"></a><code><span><span class="keyword">val</span> post_commit : <span><span class="label">xt</span>:<span><span class="type-var">'x</span> <a href="#type-t">t</a></span> <span class="arrow">&#45;&gt;</span></span> <span><span>(<span>unit <span class="arrow">&#45;&gt;</span></span> unit)</span> <span class="arrow">&#45;&gt;</span></span> unit</span></code></div><div class="spec-doc"><p><code>post_commit ~xt action</code> adds the <code>action</code> to be performed after the transaction has been committed successfully.</p></div></div><h2 id="validation"><a href="#validation" class="anchor"></a>Validation</h2><div class="odoc-spec"><div class="spec value anchored" id="val-validate"><a href="#val-validate" class="anchor"></a><code><span><span class="keyword">val</span> validate : <span><span class="label">xt</span>:<span><span class="type-var">'x</span> <a href="#type-t">t</a></span> <span class="arrow">&#45;&gt;</span></span> <span><span><span class="type-var">'a</span> <a href="../Loc/index.html#type-t">Loc.t</a></span> <span class="arrow">&#45;&gt;</span></span> unit</span></code></div><div class="spec-doc"><p><code>validate ~xt r</code> determines whether the shared memory location <code>r</code> has been modified outside of the transaction and raises <a href="../Retry/index.html#exception-Invalid"><code>Retry.Invalid</code></a> in case it has.</p><p>Due to the possibility of read skew, in cases where some important invariant should hold between two or more different shared memory locations, one may explicitly validate the locations, after reading all of them, to ensure that no read skew is possible.</p></div></div><h2 id="advanced"><a href="#advanced" class="anchor"></a>Advanced</h2><div class="odoc-spec"><div class="spec value anchored" id="val-is_in_log"><a href="#val-is_in_log" class="anchor"></a><code><span><span class="keyword">val</span> is_in_log : <span><span class="label">xt</span>:<span><span class="type-var">'x</span> <a href="#type-t">t</a></span> <span class="arrow">&#45;&gt;</span></span> <span><span><span class="type-var">'a</span> <a href="../Loc/index.html#type-t">Loc.t</a></span> <span class="arrow">&#45;&gt;</span></span> bool</span></code></div><div class="spec-doc"><p><code>is_in_log ~xt r</code> determines whether the shared memory location <code>r</code> has been accessed by the transaction.</p></div></div><h2 id="performing-accesses"><a href="#performing-accesses" class="anchor"></a>Performing accesses</h2><div class="odoc-spec"><div class="spec type anchored" id="type-tx"><a href="#type-tx" class="anchor"></a><code><span><span class="keyword">type</span> <span>'a tx</span></span><span> = </span><span>{</span></code><ol><li id="type-tx.tx" class="def record field anchored"><a href="#type-tx.tx" class="anchor"></a><code><span>tx : 'x. <span><span class="label">xt</span>:<span><span class="type-var">'x</span> <a href="#type-t">t</a></span> <span class="arrow">&#45;&gt;</span></span> <span class="type-var">'a</span>;</span></code></li></ol><code><span>}</span></code></div><div class="spec-doc"><p>Type of a transaction function that is polymorphic with respect to an explicit transaction log. The universal quantification helps to ensure that the transaction log cannot accidentally escape.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-call"><a href="#val-call" class="anchor"></a><code><span><span class="keyword">val</span> call : <span><span class="label">xt</span>:<span><span class="type-var">'x</span> <a href="#type-t">t</a></span> <span class="arrow">&#45;&gt;</span></span> <span><span><span class="type-var">'a</span> <a href="#type-tx">tx</a></span> <span class="arrow">&#45;&gt;</span></span> <span class="type-var">'a</span></span></code></div><div class="spec-doc"><p><code>call ~xt tx</code> is equivalent to <code>tx.Xt.tx ~xt</code>.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-commit"><a href="#val-commit" class="anchor"></a><code><span><span class="keyword">val</span> commit : 
  <span><span class="optlabel">?timeoutf</span>:float <span class="arrow">&#45;&gt;</span></span>
  <span><span class="optlabel">?backoff</span>:<span class="xref-unresolved">Backoff</span>.t <span class="arrow">&#45;&gt;</span></span>
  <span><span class="optlabel">?mode</span>:<a href="../Mode/index.html#type-t">Mode.t</a> <span class="arrow">&#45;&gt;</span></span>
  <span><span><span class="type-var">'a</span> <a href="#type-tx">tx</a></span> <span class="arrow">&#45;&gt;</span></span>
  <span class="type-var">'a</span></span></code></div><div class="spec-doc"><p><code>commit tx</code> repeatedly calls <code>tx</code> to record a log of shared memory accesses and attempts to perform them atomically until it succeeds and then returns whatever <code>tx</code> returned. <code>tx</code> may raise <a href="../Retry/index.html#exception-Later"><code>Retry.Later</code></a> or <a href="../Retry/index.html#exception-Invalid"><code>Retry.Invalid</code></a> to explicitly request a retry or any other exception to abort the transaction.</p><p>The default <a href="../Mode/index.html#type-t" title="Mode.t"><code>mode</code></a> for <code>commit</code> is <code>`Obstruction_free</code>. However, after enough attempts have failed during the verification step, <code>commit</code> switches to <code>`Lock_free</code>.</p></div></div></div></body></html>
