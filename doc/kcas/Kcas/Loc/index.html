<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml"><head><title>Loc (kcas.Kcas.Loc)</title><meta charset="utf-8"/><link rel="stylesheet" href="../../../odoc.support/odoc.css"/><meta name="generator" content="odoc 2.4.0"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><script src="../../../odoc.support/highlight.pack.js"></script><script>hljs.initHighlightingOnLoad();</script></head><body class="odoc"><nav class="odoc-nav"><a href="../index.html">Up</a> â€“ <a href="../../index.html">kcas</a> &#x00BB; <a href="../index.html">Kcas</a> &#x00BB; Loc</nav><header class="odoc-preamble"><h1>Module <code><span>Kcas.Loc</span></code></h1><p>Shared memory locations.</p><p>This module is essentially compatible with the <code>Stdlib.Atomic</code> module, except that a number of functions take some optional arguments that one usually need not worry about.</p></header><div class="odoc-content"><div class="odoc-spec"><div class="spec type anchored" id="type-t"><a href="#type-t" class="anchor"></a><code><span><span class="keyword">type</span> <span>!'a t</span></span><span> = </span></code><ol><li id="type-t.Loc" class="def variant constructor anchored"><a href="#type-t.Loc" class="anchor"></a><code><span>| </span><span><span class="constructor">Loc</span> : </span><span>{</span></code><ol><li id="type-t.state" class="def record field anchored"><a href="#type-t.state" class="anchor"></a><code><span>state : <span class="type-var">'state</span>;</span></code></li><li id="type-t.id" class="def record field anchored"><a href="#type-t.id" class="anchor"></a><code><span>id : <span class="type-var">'id</span>;</span></code></li></ol><code><span>}</span><span> <span class="arrow">&#45;&gt;</span> <span><span class="type-var">'a</span> <a href="#type-t">t</a></span></span></code><div class="def-doc"><span class="comment-delim">(*</span><p>The shape is transparent to allow the compiler to perform optimizations on array accesses. User code should treat this tyoe as abstract.</p><span class="comment-delim">*)</span></div></li></ol></div><div class="spec-doc"><p>Type of shared memory locations.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-make"><a href="#val-make" class="anchor"></a><code><span><span class="keyword">val</span> make : <span><span class="optlabel">?padded</span>:bool <span class="arrow">&#45;&gt;</span></span> <span><span class="optlabel">?mode</span>:<a href="../Mode/index.html#type-t">Mode.t</a> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'a</span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'a</span> <a href="#type-t">t</a></span></span></code></div><div class="spec-doc"><p><code>make initial</code> creates a new shared memory location with the <code>initial</code> value.</p><p>The optional <code>padded</code> argument defaults to <code>false</code>. If explicitly specified as <code>~padded:true</code> the location will be allocated in a way to avoid false sharing. For relatively long lived shared memory locations this can improve performance and make performance more stable at the cost of using more memory. It is not recommended to use <code>~padded:true</code> for short lived shared memory locations.</p><p>The optional <a href="../Mode/index.html#type-t" title="Mode.t"><code>mode</code></a> argument defaults to <code>`Obstruction_free</code>. If explicitly specified as <code>`Lock_free</code>, the location will always be accessed using the lock-free operating mode. This may improve performance in rare cases where a location is updated frequently and obstruction-free read-only accesses would almost certainly suffer from interference.</p><p>Locations are allocated such that accessing the locations inside a transaction in allocation order from oldest to youngest is as fast as possible.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-make_contended"><a href="#val-make_contended" class="anchor"></a><code><span><span class="keyword">val</span> make_contended : <span><span class="optlabel">?mode</span>:<a href="../Mode/index.html#type-t">Mode.t</a> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'a</span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'a</span> <a href="#type-t">t</a></span></span></code></div><div class="spec-doc"><p><code>make_contended initial</code> is equivalent to <code>make ~padded:true initial</code>.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-make_array"><a href="#val-make_array" class="anchor"></a><code><span><span class="keyword">val</span> make_array : <span><span class="optlabel">?padded</span>:bool <span class="arrow">&#45;&gt;</span></span> <span><span class="optlabel">?mode</span>:<a href="../Mode/index.html#type-t">Mode.t</a> <span class="arrow">&#45;&gt;</span></span> <span>int <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'a</span> <span class="arrow">&#45;&gt;</span></span> <span><span><span class="type-var">'a</span> <a href="#type-t">t</a></span> array</span></span></code></div><div class="spec-doc"><p><code>make_array n initial</code> creates an array of <code>n</code> new shared memory locations with the <code>initial</code> value.</p><p>The locations are allocated in such an order that accessing the locations in the array inside a transaction in order from the highest index to the lowest index is as fast as possible.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-get_mode"><a href="#val-get_mode" class="anchor"></a><code><span><span class="keyword">val</span> get_mode : <span><span><span class="type-var">'a</span> <a href="#type-t">t</a></span> <span class="arrow">&#45;&gt;</span></span> <a href="../Mode/index.html#type-t">Mode.t</a></span></code></div><div class="spec-doc"><p><code>get_mode r</code> returns the operating mode of the shared memory location <code>r</code>.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-get_id"><a href="#val-get_id" class="anchor"></a><code><span><span class="keyword">val</span> get_id : <span><span><span class="type-var">'a</span> <a href="#type-t">t</a></span> <span class="arrow">&#45;&gt;</span></span> int</span></code></div><div class="spec-doc"><p><code>get_id r</code> returns the unique id of the shared memory location <code>r</code>.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-get"><a href="#val-get" class="anchor"></a><code><span><span class="keyword">val</span> get : <span><span><span class="type-var">'a</span> <a href="#type-t">t</a></span> <span class="arrow">&#45;&gt;</span></span> <span class="type-var">'a</span></span></code></div><div class="spec-doc"><p><code>get r</code> reads the current value of the shared memory location <code>r</code>.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-get_as"><a href="#val-get_as" class="anchor"></a><code><span><span class="keyword">val</span> get_as : <span><span class="optlabel">?timeoutf</span>:float <span class="arrow">&#45;&gt;</span></span> <span><span>(<span><span class="type-var">'a</span> <span class="arrow">&#45;&gt;</span></span> <span class="type-var">'b</span>)</span> <span class="arrow">&#45;&gt;</span></span> <span><span><span class="type-var">'a</span> <a href="#type-t">t</a></span> <span class="arrow">&#45;&gt;</span></span> <span class="type-var">'b</span></span></code></div><div class="spec-doc"><p><code>get_as f loc</code> is equivalent to <code>f (get loc)</code>. The given function <code>f</code> may raise the <a href="../Retry/index.html#exception-Later"><code>Retry.Later</code></a> exception to signal that the conditional load should be retried only after the location has been modified outside of the conditional load. It is also safe for the given function <code>f</code> to raise any other exception to abort the conditional load.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-compare_and_set"><a href="#val-compare_and_set" class="anchor"></a><code><span><span class="keyword">val</span> compare_and_set : <span><span class="optlabel">?backoff</span>:<span class="xref-unresolved">Backoff</span>.t <span class="arrow">&#45;&gt;</span></span> <span><span><span class="type-var">'a</span> <a href="#type-t">t</a></span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'a</span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'a</span> <span class="arrow">&#45;&gt;</span></span> bool</span></code></div><div class="spec-doc"><p><code>compare_and_set r before after</code> atomically updates the shared memory location <code>r</code> to the <code>after</code> value if the current value of <code>r</code> is the <code>before</code> value.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-update"><a href="#val-update" class="anchor"></a><code><span><span class="keyword">val</span> update : <span><span class="optlabel">?timeoutf</span>:float <span class="arrow">&#45;&gt;</span></span> <span><span class="optlabel">?backoff</span>:<span class="xref-unresolved">Backoff</span>.t <span class="arrow">&#45;&gt;</span></span> <span><span><span class="type-var">'a</span> <a href="#type-t">t</a></span> <span class="arrow">&#45;&gt;</span></span> <span><span>(<span><span class="type-var">'a</span> <span class="arrow">&#45;&gt;</span></span> <span class="type-var">'a</span>)</span> <span class="arrow">&#45;&gt;</span></span> <span class="type-var">'a</span></span></code></div><div class="spec-doc"><p><code>update r f</code> repeats <code>let b = get r in compare_and_set r b (f b)</code> until it succeeds and then returns the <code>b</code> value. The given function <code>f</code> may raise the <a href="../Retry/index.html#exception-Later"><code>Retry.Later</code></a> exception to signal that the update should only be retried after the location has been modified outside of the update. It is also safe for the given function <code>f</code> to raise any other exception to abort the update.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-modify"><a href="#val-modify" class="anchor"></a><code><span><span class="keyword">val</span> modify : 
  <span><span class="optlabel">?timeoutf</span>:float <span class="arrow">&#45;&gt;</span></span>
  <span><span class="optlabel">?backoff</span>:<span class="xref-unresolved">Backoff</span>.t <span class="arrow">&#45;&gt;</span></span>
  <span><span><span class="type-var">'a</span> <a href="#type-t">t</a></span> <span class="arrow">&#45;&gt;</span></span>
  <span><span>(<span><span class="type-var">'a</span> <span class="arrow">&#45;&gt;</span></span> <span class="type-var">'a</span>)</span> <span class="arrow">&#45;&gt;</span></span>
  unit</span></code></div><div class="spec-doc"><p><code>modify r f</code> is equivalent to <code>update r f |&gt; ignore</code>.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-exchange"><a href="#val-exchange" class="anchor"></a><code><span><span class="keyword">val</span> exchange : <span><span class="optlabel">?backoff</span>:<span class="xref-unresolved">Backoff</span>.t <span class="arrow">&#45;&gt;</span></span> <span><span><span class="type-var">'a</span> <a href="#type-t">t</a></span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'a</span> <span class="arrow">&#45;&gt;</span></span> <span class="type-var">'a</span></span></code></div><div class="spec-doc"><p><code>exchange r after</code> atomically updates the shared memory location <code>r</code> to the <code>after</code> value and returns the current value (before the exchange).</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-set"><a href="#val-set" class="anchor"></a><code><span><span class="keyword">val</span> set : <span><span class="optlabel">?backoff</span>:<span class="xref-unresolved">Backoff</span>.t <span class="arrow">&#45;&gt;</span></span> <span><span><span class="type-var">'a</span> <a href="#type-t">t</a></span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'a</span> <span class="arrow">&#45;&gt;</span></span> unit</span></code></div><div class="spec-doc"><p><code>set r after</code> atomically updates the shared memory location <code>r</code> to the <code>after</code> value.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-fetch_and_add"><a href="#val-fetch_and_add" class="anchor"></a><code><span><span class="keyword">val</span> fetch_and_add : <span><span class="optlabel">?backoff</span>:<span class="xref-unresolved">Backoff</span>.t <span class="arrow">&#45;&gt;</span></span> <span><span>int <a href="#type-t">t</a></span> <span class="arrow">&#45;&gt;</span></span> <span>int <span class="arrow">&#45;&gt;</span></span> int</span></code></div><div class="spec-doc"><p><code>fetch_and_add r n</code> atomically increments the value of <code>r</code> by <code>n</code>, and returns the current value (before the increment).</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-incr"><a href="#val-incr" class="anchor"></a><code><span><span class="keyword">val</span> incr : <span><span class="optlabel">?backoff</span>:<span class="xref-unresolved">Backoff</span>.t <span class="arrow">&#45;&gt;</span></span> <span><span>int <a href="#type-t">t</a></span> <span class="arrow">&#45;&gt;</span></span> unit</span></code></div><div class="spec-doc"><p><code>incr r</code> atomically increments <code>r</code>.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-decr"><a href="#val-decr" class="anchor"></a><code><span><span class="keyword">val</span> decr : <span><span class="optlabel">?backoff</span>:<span class="xref-unresolved">Backoff</span>.t <span class="arrow">&#45;&gt;</span></span> <span><span>int <a href="#type-t">t</a></span> <span class="arrow">&#45;&gt;</span></span> unit</span></code></div><div class="spec-doc"><p><code>decr r</code> atomically decrements <code>r</code>.</p></div></div></div></body></html>
