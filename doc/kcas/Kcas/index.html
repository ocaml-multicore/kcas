<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml"><head><title>Kcas (kcas.Kcas)</title><link rel="stylesheet" href="../../odoc.support/odoc.css"/><meta charset="utf-8"/><meta name="generator" content="odoc 2.2.0"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><script src="../../odoc.support/highlight.pack.js"></script><script>hljs.initHighlightingOnLoad();</script></head><body class="odoc"><nav class="odoc-nav"><a href="../index.html">Up</a> â€“ <a href="../index.html">kcas</a> &#x00BB; Kcas</nav><header class="odoc-preamble"><h1>Module <code><span>Kcas</span></code></h1><p>This library provides a software transactional memory (STM) implementation based on an atomic lock-free multi-word compare-and-set (MCAS) algorithm enhanced with read-only compare operations and ability to block awaiting for changes.</p><p>Features and properties:</p><ul><li><b>Efficient</b>: In the common uncontended case only <code>k + 1</code> single-word CASes are required per <code>k</code>-CAS and, as a special case, <code>1</code>-CAS requires only a single single-word CAS.</li></ul><ul><li><b>Lock-free</b>: The underlying algorithm guarantees that at least one operation will be able to make progress.</li></ul><ul><li><b>Disjoint-access parallel</b>: Unrelated operations progress independently, without interference, even if they occur at the same time.</li></ul><ul><li><b>Read-only compares</b>: The algorithm supports <a href="https://en.wikipedia.org/wiki/Non-blocking_algorithm#Obstruction-freedom">obstruction-free</a> read-only compare (CMP) operations that can be performed on overlapping locations in parallel without interference.</li></ul><ul><li><b>Blocking await</b>: The algorithm supports timeouts and awaiting for changes to any number of shared memory locations.</li></ul><ul><li><b>Composable</b>: Independently developed transactions can be composed with ease sequentially, conjunctively, conditionally, and disjunctively.</li></ul><p>In other words, performance should be acceptable and scalable for many use cases, the non-blocking properties should allow use in many contexts including those where locks are not acceptable, and the features provided should support most practical needs.</p></header><nav class="odoc-toc"><ul><li><a href="#a-quick-tour">A quick tour</a></li><li><a href="#auxiliary-modules">Auxiliary modules</a></li><li><a href="#individual-locations">Individual locations</a></li><li><a href="#manipulating-multiple-locations-atomically">Manipulating multiple locations atomically</a></li></ul></nav><div class="odoc-content"><h2 id="a-quick-tour"><a href="#a-quick-tour" class="anchor"></a>A quick tour</h2><p>To use the library one first creates shared memory locations:</p><pre class="language-ocaml"><code># let a = Loc.make 0
  and b = Loc.make 0
  and x = Loc.make 0
val a : int Loc.t = &lt;abstr&gt;
val b : int Loc.t = &lt;abstr&gt;
val x : int Loc.t = &lt;abstr&gt;</code></pre><p>One can then manipulate the locations individually:</p><pre class="language-ocaml"><code># Loc.set a 6
- : unit = ()

# Loc.get a
- : int = 6</code></pre><p>Attempt primitive operations over multiple locations:</p><pre class="language-ocaml"><code># Op.atomically [
    Op.make_cas a 6 10;
    Op.make_cas b 0 52
  ]
- : bool = true</code></pre><p>Block waiting for changes to locations:</p><pre class="language-ocaml"><code># let a_domain = Domain.spawn @@ fun () -&gt;
    let x = Loc.get_as (fun x -&gt; Retry.unless (x &lt;&gt; 0); x) x in
    Printf.sprintf &quot;The answer is %d!&quot; x
val a_domain : string Domain.t = &lt;abstr&gt;</code></pre><p>Perform transactions over locations:</p><pre class="language-ocaml"><code># let tx ~xt =
    let a = Xt.get ~xt a
    and b = Xt.get ~xt b in
    Xt.set ~xt x (b - a)
  in
  Xt.commit { tx }
- : unit = ()</code></pre><p>And now we have it:</p><pre class="language-ocaml"><code># Domain.join a_domain
- : string = &quot;The answer is 42!&quot;</code></pre><p>The main repository includes a longer introduction with many examples and discussion of more advanced topics for designing lock-free algorithms.</p><h2 id="auxiliary-modules"><a href="#auxiliary-modules" class="anchor"></a>Auxiliary modules</h2><p>The modules in this section serve auxiliary purposes. On a first read you can skip over these. The documentation links back to these modules where appropriate.</p><div class="odoc-spec"><div class="spec module anchored" id="module-Timeout"><a href="#module-Timeout" class="anchor"></a><code><span><span class="keyword">module</span> <a href="Timeout/index.html">Timeout</a></span><span> : <span class="keyword">sig</span> ... <span class="keyword">end</span></span></code></div><div class="spec-doc"><p>Timeout support.</p></div></div><div class="odoc-spec"><div class="spec module anchored" id="module-Retry"><a href="#module-Retry" class="anchor"></a><code><span><span class="keyword">module</span> <a href="Retry/index.html">Retry</a></span><span> : <span class="keyword">sig</span> ... <span class="keyword">end</span></span></code></div><div class="spec-doc"><p>Retry support.</p></div></div><div class="odoc-spec"><div class="spec module anchored" id="module-Mode"><a href="#module-Mode" class="anchor"></a><code><span><span class="keyword">module</span> <a href="Mode/index.html">Mode</a></span><span> : <span class="keyword">sig</span> ... <span class="keyword">end</span></span></code></div><div class="spec-doc"><p>Operating modes of the <code>k-CAS-n-CMP</code> algorithm.</p></div></div><h2 id="individual-locations"><a href="#individual-locations" class="anchor"></a>Individual locations</h2><p>Individual shared memory locations can be created and manipulated through the <a href="Loc/index.html"><code>Loc</code></a> module that is essentially compatible with the <code>Stdlib.Atomic</code> module except that some of the operations take additional optional arguments:</p><ul><li><code>backoff</code> specifies the configuration for the <code>Backoff</code> mechanism. In special cases, having more detailed knowledge of the application, one might adjust the configuration to improve performance.</li></ul><ul><li><code>timeoutf</code> specifies a timeout in seconds and, if specified, the <a href="Timeout/index.html#exception-Timeout"><code>Timeout.Timeout</code></a> exception may be raised by the operation to signal that the timeout expired.</li></ul><div class="odoc-spec"><div class="spec module anchored" id="module-Loc"><a href="#module-Loc" class="anchor"></a><code><span><span class="keyword">module</span> <a href="Loc/index.html">Loc</a></span><span> : <span class="keyword">sig</span> ... <span class="keyword">end</span></span></code></div><div class="spec-doc"><p>Shared memory locations.</p></div></div><h2 id="manipulating-multiple-locations-atomically"><a href="#manipulating-multiple-locations-atomically" class="anchor"></a>Manipulating multiple locations atomically</h2><p>Multiple shared memory locations can be manipulated atomically using either</p><ul><li>the <a href="Xt/index.html"><code>Xt</code></a> module, to explicitly pass a transaction log to record accesses, or</li></ul><ul><li>the <a href="Op/index.html"><code>Op</code></a> module, to specify a list of primitive operations to perform.</li></ul><p>Atomic operations over multiple shared memory locations are performed in two or three phases:</p><p>1. The first phase essentially records a list or log of operations to access shared memory locations. The first phase involves code you write as a user of the library. Aside from some advanced techniques, shared memory locations are not mutated during this phase.</p><p>2. The second phase attempts to perform the operations atomically. This is done internally by the library implementation. Only logically invisible writes to shared memory locations are performed during this phase.</p><p>3. In <a href="Mode/index.html#val-obstruction_free"><code>Mode.obstruction_free</code></a> a third phase verifies all read-only operations. This is also done internally by the library implementation.</p><p>Each phase may fail. In particular, in the first phase, as no changes to shared memory have yet been attempted, it is safe, for example, to raise exceptions to signal failure. Failure on the third phase raises <a href="Mode/index.html#exception-Interference"><code>Mode.Interference</code></a>, which is automatically handled by <a href="Xt/index.html#val-commit"><code>Xt.commit</code></a>.</p><p>Only after all phases have completed succesfully, the writes to shared memory locations are atomically marked as having taken effect and subsequent reads of the locations will be able to see the newly written values.</p><div class="odoc-spec"><div class="spec module anchored" id="module-Xt"><a href="#module-Xt" class="anchor"></a><code><span><span class="keyword">module</span> <a href="Xt/index.html">Xt</a></span><span> : <span class="keyword">sig</span> ... <span class="keyword">end</span></span></code></div><div class="spec-doc"><p>Explicit transaction log passing on shared memory locations.</p></div></div><div class="odoc-spec"><div class="spec module anchored" id="module-Op"><a href="#module-Op" class="anchor"></a><code><span><span class="keyword">module</span> <a href="Op/index.html">Op</a></span><span> : <span class="keyword">sig</span> ... <span class="keyword">end</span></span></code></div><div class="spec-doc"><p>Multi-word compare-and-set operations on shared memory locations.</p></div></div></div></body></html>