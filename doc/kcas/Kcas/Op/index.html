<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml"><head><title>Op (kcas.Kcas.Op)</title><link rel="stylesheet" href="../../../odoc.support/odoc.css"/><meta charset="utf-8"/><meta name="generator" content="odoc 2.2.0"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><script src="../../../odoc.support/highlight.pack.js"></script><script>hljs.initHighlightingOnLoad();</script></head><body class="odoc"><nav class="odoc-nav"><a href="../index.html">Up</a> â€“ <a href="../../index.html">kcas</a> &#x00BB; <a href="../index.html">Kcas</a> &#x00BB; Op</nav><header class="odoc-preamble"><h1>Module <code><span>Kcas.Op</span></code></h1><p>Multi-word compare-and-set operations on shared memory locations.</p><p>This module provides a multi-word compare-and-set (MCAS) interface for manipulating multiple locations atomically. This is a low-level interface not intended for most users.</p><p>As an example, consider an implementation of doubly-linked circular lists. Instead of using a mutable field, <code>ref</code>, or <code>Atomic.t</code>, one would use a shared memory location, or <a href="../Loc/index.html#type-t"><code>Loc.t</code></a>, for the pointers in the node type:</p><pre class="language-ocaml"><code>type 'a node = {
  succ: 'a node Loc.t;
  pred: 'a node Loc.t;
  datum: 'a;
}</code></pre><p>To remove a node safely one wants to atomically update the <code>succ</code> and <code>pred</code> pointers of the predecessor and successor nodes and to also update the <code>succ</code> and <code>pred</code> pointers of a node to point to the node itself, so that removal becomes an <a href="https://en.wikipedia.org/wiki/Idempotence">idempotent</a> operation. Using a multi-word compare-and-set one could implement the <code>remove</code> operation as follows:</p><pre class="language-ocaml"><code>let rec remove ?(backoff = Backoff.default) node =
  (* Read pointer to the predecessor node and... *)
  let pred = Loc.get node.pred in
  (* ..check whether the node has already been removed. *)
  if pred != node then
    let succ = Loc.get node.succ in
    let ok = Op.atomically [
      (* Update pointers in this node: *)
      Op.make_cas node.succ succ node;
      Op.make_cas node.pred pred node;
      (* Update pointers to this node: *)
      Op.make_cas pred.succ node succ;
      Op.make_cas succ.pred node pred;
    ] in
    if not ok then
      (* Someone modified the list around us, so backoff and retry. *)
      remove ~backoff:(Backoff.once backoff) node</code></pre><p>The list given to <a href="#val-atomically"><code>Op.atomically</code></a> contains specifications of the individual compare-and-set operations to perform. A single <a href="#val-make_cas"><code>Op.make_cas</code></a> specifies an operation to compare the current value of a location with the expected value and, in case they are the same, set the value of the location to the desired value.</p><p>Programming with like this is similar to programming with single-word compare-and-set except that the operation is extended to being able to work on multiple words.</p></header><div class="odoc-content"><div class="odoc-spec"><div class="spec type anchored" id="type-t"><a href="#type-t" class="anchor"></a><code><span><span class="keyword">type</span> t</span></code></div><div class="spec-doc"><p>Type of operations on shared memory locations.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-make_cas"><a href="#val-make_cas" class="anchor"></a><code><span><span class="keyword">val</span> make_cas : <span><span><span class="type-var">'a</span> <a href="../Loc/index.html#type-t">Loc.t</a></span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'a</span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'a</span> <span class="arrow">&#45;&gt;</span></span> <a href="#type-t">t</a></span></code></div><div class="spec-doc"><p><code>make_cas r before after</code> specifies an operation that attempts to set the shared memory location <code>r</code> to the <code>after</code> value and succeeds if the current content of <code>r</code> is the <code>before</code> value.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-make_cmp"><a href="#val-make_cmp" class="anchor"></a><code><span><span class="keyword">val</span> make_cmp : <span><span><span class="type-var">'a</span> <a href="../Loc/index.html#type-t">Loc.t</a></span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'a</span> <span class="arrow">&#45;&gt;</span></span> <a href="#type-t">t</a></span></code></div><div class="spec-doc"><p><code>make_cmp r expected</code> specifies an operation that succeeds if the current value of the shared memory location <code>r</code> is the <code>expected</code> value.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-get_id"><a href="#val-get_id" class="anchor"></a><code><span><span class="keyword">val</span> get_id : <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span> int</span></code></div><div class="spec-doc"><p><code>get_id op</code> returns the unique id of the shared memory reference targeted by the <code>op</code>eration.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-is_on_loc"><a href="#val-is_on_loc" class="anchor"></a><code><span><span class="keyword">val</span> is_on_loc : <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span> <span><span><span class="type-var">'a</span> <a href="../Loc/index.html#type-t">Loc.t</a></span> <span class="arrow">&#45;&gt;</span></span> bool</span></code></div><div class="spec-doc"><p><code>is_on_loc op r</code> determines whether the target of <code>op</code> is the shared memory location <code>r</code>.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-atomic"><a href="#val-atomic" class="anchor"></a><code><span><span class="keyword">val</span> atomic : <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span> bool</span></code></div><div class="spec-doc"><p><code>atomic op</code> attempts to perform the specified operation atomically. Returns <code>true</code> on success and <code>false</code> on failure.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-atomically"><a href="#val-atomically" class="anchor"></a><code><span><span class="keyword">val</span> atomically : <span>?mode:<a href="../Mode/index.html#type-t">Mode.t</a> <span class="arrow">&#45;&gt;</span></span> <span><span><a href="#type-t">t</a> list</span> <span class="arrow">&#45;&gt;</span></span> bool</span></code></div><div class="spec-doc"><p><code>atomically ops</code> attempts to perform the specified operations atomically. If used in <a href="../Mode/index.html#val-obstruction_free"><code>Mode.obstruction_free</code></a> may raise <a href="../Mode/index.html#exception-Interference"><code>Mode.Interference</code></a>. Otherwise returns <code>true</code> on success and <code>false</code> on failure. The default for <code>atomically</code> is <a href="../Mode/index.html#val-lock_free"><code>Mode.lock_free</code></a>.</p><p>The algorithm requires provided operations to follow a global total order. To eliminate a class of bugs, the operations are sorted automatically. If the operations are given in either ascending or descending order of the targeted shared memory location ids, then sorting is done in linear time <code>O(n)</code> and does not increase the time complexity of the algorithm. Otherwise sorting may take linearithmic time <code>O(n*log(n))</code>.</p></div></div></div></body></html>