<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml"><head><title>Kcas_data (kcas_data.Kcas_data)</title><meta charset="utf-8"/><link rel="stylesheet" href="../../odoc.support/odoc.css"/><meta name="generator" content="odoc 2.4.1"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><script src="../../odoc.support/highlight.pack.js"></script><script>hljs.initHighlightingOnLoad();</script><script>let base_url = '../../';
let search_urls = ['../db.js','../../sherlodoc.js'];
</script><script src="../../odoc.support/odoc_search.js" defer="defer"></script></head><body class="odoc"><nav class="odoc-nav"><a href="../index.html">Up</a> â€“ <a href="../index.html">kcas_data</a> &#x00BB; Kcas_data</nav><div class="odoc-search"><div class="search-inner"><input class="search-bar" placeholder="ðŸ”Ž Search..."/><div class="search-snake"></div><div class="search-result"></div></div></div><header class="odoc-preamble"><h1>Module <code><span>Kcas_data</span></code></h1><p>This is a library of compositional lock-free data structures and primitives for communication and synchronization implemented using <a href="../../kcas/Kcas/index.html"><code>Kcas</code></a>.</p><p>All data structure implementations in this library are concurrency and parallelism safe and should strive to provide the following guarantees:</p><ul><li>Provided operations are <i>strictly serializable</i> (i.e. both <a href="https://en.wikipedia.org/wiki/Linearizability">linerizable</a> and <a href="https://en.wikipedia.org/wiki/Serializability">serializable</a>).</li><li>Provided operations are efficient, either (<a href="https://en.wikipedia.org/wiki/Amortized_analysis">amortized</a>) constant time, <code>O(1)</code>, or logarithmic time, <code>O(log(n))</code>.</li><li>Provided operations are <a href="https://en.wikipedia.org/wiki/Non-blocking_algorithm#Lock-freedom">lock-free</a> and designed to avoid <a href="https://en.wikipedia.org/wiki/Starvation_(computer_science)">starvation</a> under moderate contention.</li><li>Provided read-only operations scale perfectly when only read-only operations are performed in parallel.</li></ul><p>Unobvious exceptions to the above guarantees should be clearly and explicitly documented.</p><p>The main feature of these data structure implementations is their compositionality. If your application does not need compositionality, then other concurrency and parallelism safe data structure libraries may potentially offer better performance.</p><p>But why should you care about composability?</p><p>As an example, consider the implementation of a least-recently-used (LRU) cache or a bounded associative map, but first, let's open the libraries for convenience:</p><pre class="language-ocaml"><code>open Kcas
open Kcas_data</code></pre><p>A simple sequential approach to implement a LRU cache is to use a hash table and a doubly-linked list and keep track of the amount of space in the cache:</p><pre class="language-ocaml"><code>type ('k, 'v) cache =
  { space: int Loc.t;
    table: ('k, 'k Dllist.node * 'v) Hashtbl.t;
    order: 'k Dllist.t }</code></pre><p>On a cache lookup the doubly-linked list node corresponding to the accessed key is moved to the left end of the list:</p><pre class="language-ocaml"><code>let get_opt {table; order; _} key =
  Hashtbl.find_opt table key
  |&gt; Option.map @@ fun (node, datum) -&gt;
     Dllist.move_l node order; datum</code></pre><p>On a cache update, in case of overflow, the association corresponding to the node on the right end of the list is dropped:</p><pre class="language-ocaml"><code>let set {table; order; space; _} key datum =
  let node =
    match Hashtbl.find_opt table key with
    | None -&gt;
      if 0 = Loc.update space (fun n -&gt; max 0 (n-1))
      then Dllist.take_opt_r order
           |&gt; Option.iter (Hashtbl.remove table);
      Dllist.add_l key order
    | Some (node, _) -&gt; Dllist.move_l node order; node
  in
  Hashtbl.replace table key (node, datum)</code></pre><p>Sequential algorithms such as the above are so common that one does not even think about them. Unfortunately, in a concurrent setting the above doesn't work even if the individual operations on lists and hash tables were atomic as they are in this library.</p><p>But how would one make the operations on a cache atomic as a whole? As explained by Maurice Herlihy in one of his talks on <a href="https://youtu.be/ZkUrl8BZHjk?t=1503">Transactional Memory</a> adding locks to protect the atomicity of the operation is far from trivial.</p><p>Fortunately, rather than having to e.g. wrap the cache implementation behind a <a href="https://en.wikipedia.org/wiki/Lock_(computer_science)">mutex</a> and make another individually atomic yet uncomposable data structure, or having to learn a completely different programming model and rewrite the cache implementation, we can use the transactional programming model provided by the <a href="../../kcas/Kcas/index.html"><code>Kcas</code></a> library and the transactional data structures provided by this library to trivially convert the previous implementation to a lock-free composable transactional data structure.</p><p>To make it so, we simply use transactional versions, <code>*.Xt.*</code>, of operations on the data structures and explicitly pass a transaction log, <code>~xt</code>, to the operations. For the <code>get_opt</code> operation we end up with</p><pre class="language-ocaml"><code>let get_opt ~xt {table; order; _} key =
  Hashtbl.Xt.find_opt ~xt table key
  |&gt; Option.map @@ fun (node, datum) -&gt;
     Dllist.Xt.move_l ~xt node order; datum</code></pre><p>and the <code>set</code> operation is just as easy to convert to a transactional version. One way to think about transactions is that they give us back the ability to compose programs such as the above.</p></header><nav class="odoc-toc"><ul><li><a href="#stdlib-style-data-structures"><code>Stdlib</code> style data structures</a></li><li><a href="#communication-and-synchronization-primitives">Communication and synchronization primitives</a></li><li><a href="#linked-data-structures">Linked data structures</a></li><li><a href="#utilities">Utilities</a></li></ul></nav><div class="odoc-content"><h2 id="stdlib-style-data-structures"><a href="#stdlib-style-data-structures" class="anchor"></a><code>Stdlib</code> style data structures</h2><p>The data structures in this section are designed to closely mimic the corresponding unsynchronized data structures in the OCaml <code>Stdlib</code>. Each of these provide a non-compositional, but concurrency and parallelism safe, interface that is close to the <code>Stdlib</code> equivalent. Additionally, compositional transactional interfaces are provided for some operations.</p><p>These implementations will use more space than the corresponding <code>Stdlib</code> data structures. Performance, when accessed concurrently, should be competitive or superior compared to naÃ¯ve locking.</p><div class="odoc-spec"><div class="spec module anchored" id="module-Hashtbl"><a href="#module-Hashtbl" class="anchor"></a><code><span><span class="keyword">module</span> <a href="Hashtbl/index.html">Hashtbl</a></span><span> : <span class="keyword">sig</span> ... <span class="keyword">end</span></span></code></div><div class="spec-doc"><p>Hash table.</p></div></div><div class="odoc-spec"><div class="spec module anchored" id="module-Queue"><a href="#module-Queue" class="anchor"></a><code><span><span class="keyword">module</span> <a href="Queue/index.html">Queue</a></span><span> : <span class="keyword">sig</span> ... <span class="keyword">end</span></span></code></div><div class="spec-doc"><p>First-In First-Out (FIFO) queue.</p></div></div><div class="odoc-spec"><div class="spec module anchored" id="module-Stack"><a href="#module-Stack" class="anchor"></a><code><span><span class="keyword">module</span> <a href="Stack/index.html">Stack</a></span><span> : <span class="keyword">sig</span> ... <span class="keyword">end</span></span></code></div><div class="spec-doc"><p>Last-In First-Out (LIFO) stack.</p></div></div><h2 id="communication-and-synchronization-primitives"><a href="#communication-and-synchronization-primitives" class="anchor"></a>Communication and synchronization primitives</h2><div class="odoc-spec"><div class="spec module anchored" id="module-Mvar"><a href="#module-Mvar" class="anchor"></a><code><span><span class="keyword">module</span> <a href="Mvar/index.html">Mvar</a></span><span> : <span class="keyword">sig</span> ... <span class="keyword">end</span></span></code></div><div class="spec-doc"><p>Synchronizing variable.</p></div></div><div class="odoc-spec"><div class="spec module anchored" id="module-Promise"><a href="#module-Promise" class="anchor"></a><code><span><span class="keyword">module</span> <a href="Promise/index.html">Promise</a></span><span> : <span class="keyword">sig</span> ... <span class="keyword">end</span></span></code></div><div class="spec-doc"><p>A promise of a value to be resolved at some point in the future.</p></div></div><h2 id="linked-data-structures"><a href="#linked-data-structures" class="anchor"></a>Linked data structures</h2><div class="odoc-spec"><div class="spec module anchored" id="module-Dllist"><a href="#module-Dllist" class="anchor"></a><code><span><span class="keyword">module</span> <a href="Dllist/index.html">Dllist</a></span><span> : <span class="keyword">sig</span> ... <span class="keyword">end</span></span></code></div><div class="spec-doc"><p>Doubly-linked list.</p></div></div><h2 id="utilities"><a href="#utilities" class="anchor"></a>Utilities</h2><div class="odoc-spec"><div class="spec module anchored" id="module-Accumulator"><a href="#module-Accumulator" class="anchor"></a><code><span><span class="keyword">module</span> <a href="Accumulator/index.html">Accumulator</a></span><span> : <span class="keyword">sig</span> ... <span class="keyword">end</span></span></code></div><div class="spec-doc"><p>Scalable accumulator.</p></div></div></div></body></html>
