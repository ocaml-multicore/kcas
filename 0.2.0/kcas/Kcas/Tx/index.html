<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml"><head><title>Tx (kcas.Kcas.Tx)</title><link rel="stylesheet" href="../../../odoc.css"/><meta charset="utf-8"/><meta name="generator" content="odoc 2.2.0"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><script src="../../../highlight.pack.js"></script><script>hljs.initHighlightingOnLoad();</script></head><body class="odoc"><nav class="odoc-nav"><a href="../index.html">Up</a> â€“ <a href="../../index.html">kcas</a> &#x00BB; <a href="../index.html">Kcas</a> &#x00BB; Tx</nav><header class="odoc-preamble"><h1>Module <code><span>Kcas.Tx</span></code></h1><p>Transactions on shared memory locations.</p></header><div class="odoc-content"><div class="odoc-spec"><div class="spec type anchored" id="type-t"><a href="#type-t" class="anchor"></a><code><span><span class="keyword">type</span> <span>'a t</span></span></code></div><div class="spec-doc"><p>Type of transactions on shared memory locations.</p><p>A transaction can be thought of as a specification of a sequence of <a href="#val-get"><code>get</code></a> and <a href="#val-set"><code>set</code></a> accesses to shared memory locations that can be <a href="#val-attempt"><code>attempt</code></a>ed to perform the accesses atomically.</p><p>Transactions can be composed both sequentially (see <a href="#val-let*"><code>let*</code></a>) and conditionally (see <a href="#val-(&lt;|&gt;)"><code>(&lt;|&gt;)</code></a> and <a href="#val-forget"><code>forget</code></a>).</p><p>Transactions are performed in two phases:</p><p>1. The first phase essentially records a log of operations based on the <a href="#val-get"><code>get</code></a> and <a href="#val-set"><code>set</code></a> accesses of shared memory locations.</p><p>2. The second phase attempts to perform the operations atomically.</p><p>Either phase may fail. In particular, the first phase is allowed to raise exceptions to signal failure.</p><p>Here is an example of unconditionally <a href="#val-commit"><code>commit</code></a>ting a transaction that swaps the values of the two shared memory locations <code>x_loc</code> and <code>y_loc</code> and returns their sum:</p><pre class="language-ocaml"><code>commit begin
  let* x = get x_loc
  and* y = get y_loc in
  let+ () = set y_loc x
  and+ () = set x_loc y in
  x + y
end</code></pre><p>Above, <code>get y_loc</code> and <code>set y_loc x</code> are intentionally one after the other, because the internal log used within transactions to record <a href="#val-get"><code>get</code></a>s and <a href="#val-set"><code>set</code></a>s is optimized for accessing recently accessed elements again.</p><p>Here is an example of <a href="#val-attempt"><code>attempt</code></a>ing a conditional transaction</p><pre class="language-ocaml"><code>attempt begin
  begin
    let* x = get x_loc in
    if x &lt; 0 then
      forget
    else
      return x
  end
  &lt;|&gt; get y_loc
end</code></pre><p>that reads <code>x_loc</code>, but <a href="#val-forget"><code>forget</code></a>s the access in case <code>x_loc</code> had a negative value and then reads <code>y_loc</code> instead.</p><p>What does that actually mean? Let's assume <code>x_loc</code> initially contains a negative value. During the first phase of the transaction <code>x_loc</code> is read and is found to be negative. The access is forgotten. Let's assume that after that the value of <code>x_loc</code> is modified by some other domain. The transaction continues to read <code>y_loc</code> and results in the value of <code>y_loc</code>. The transaction is allowed to commit despite the value of <code>x_loc</code> having been changed during the transaction.</p><p>Consider the following similar looking conditional transaction <a href="#val-attempt"><code>attempt</code></a>:</p><pre class="language-ocaml"><code>attempt begin
  let* x = get x_loc in
  if x &lt; 0 then
    get y_loc
  else
    return x
end</code></pre><p>If some other domain modifies <code>x_loc</code> after it has been read by the above transaction attempt, then the commit phase will fail, because the access of <code>x_loc</code> is found to be inconsistent.</p><p>Note that neither of the above conditional examples is generally preferred, because they have fundamentally different semantics and the choice of whether accesses should, should not, or may be safely forgotten depends on what the desired semantics are for the transaction.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-get"><a href="#val-get" class="anchor"></a><code><span><span class="keyword">val</span> get : <span><span><span class="type-var">'a</span> <a href="../Loc/index.html#type-t">Loc.t</a></span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'a</span> <a href="#type-t">t</a></span></span></code></div><div class="spec-doc"><p><code>get r</code> accesses the shared memory location <code>r</code> inside the transaction and results in the current value of <code>r</code> inside the transaction.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-get_as"><a href="#val-get_as" class="anchor"></a><code><span><span class="keyword">val</span> get_as : <span><span>(<span><span class="type-var">'a</span> <span class="arrow">&#45;&gt;</span></span> <span class="type-var">'b</span>)</span> <span class="arrow">&#45;&gt;</span></span> <span><span><span class="type-var">'a</span> <a href="../Loc/index.html#type-t">Loc.t</a></span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'b</span> <a href="#type-t">t</a></span></span></code></div><div class="spec-doc"><p><code>get_as g r</code> is equivalent to <code>get r |&gt; map g</code>.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-set"><a href="#val-set" class="anchor"></a><code><span><span class="keyword">val</span> set : <span><span><span class="type-var">'a</span> <a href="../Loc/index.html#type-t">Loc.t</a></span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'a</span> <span class="arrow">&#45;&gt;</span></span> <span>unit <a href="#type-t">t</a></span></span></code></div><div class="spec-doc"><p><code>set r v</code> accesses the shared memory location <code>r</code> inside the transaction and sets the current value of <code>r</code> to the value <code>v</code> inside the transaction.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-update"><a href="#val-update" class="anchor"></a><code><span><span class="keyword">val</span> update : <span><span><span class="type-var">'a</span> <a href="../Loc/index.html#type-t">Loc.t</a></span> <span class="arrow">&#45;&gt;</span></span> <span><span>(<span><span class="type-var">'a</span> <span class="arrow">&#45;&gt;</span></span> <span class="type-var">'a</span>)</span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'a</span> <a href="#type-t">t</a></span></span></code></div><div class="spec-doc"><p><code>update r f</code> is equivalent to <code>let* x = get r in let+ () = set r (f x) in x</code>.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-update_as"><a href="#val-update_as" class="anchor"></a><code><span><span class="keyword">val</span> update_as : <span><span>(<span><span class="type-var">'a</span> <span class="arrow">&#45;&gt;</span></span> <span class="type-var">'b</span>)</span> <span class="arrow">&#45;&gt;</span></span> <span><span><span class="type-var">'a</span> <a href="../Loc/index.html#type-t">Loc.t</a></span> <span class="arrow">&#45;&gt;</span></span> <span><span>(<span><span class="type-var">'a</span> <span class="arrow">&#45;&gt;</span></span> <span class="type-var">'a</span>)</span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'b</span> <a href="#type-t">t</a></span></span></code></div><div class="spec-doc"><p><code>update_as g r f</code> is equivalent to <code>update r f |&gt; map g</code>.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-modify"><a href="#val-modify" class="anchor"></a><code><span><span class="keyword">val</span> modify : <span><span><span class="type-var">'a</span> <a href="../Loc/index.html#type-t">Loc.t</a></span> <span class="arrow">&#45;&gt;</span></span> <span><span>(<span><span class="type-var">'a</span> <span class="arrow">&#45;&gt;</span></span> <span class="type-var">'a</span>)</span> <span class="arrow">&#45;&gt;</span></span> <span>unit <a href="#type-t">t</a></span></span></code></div><div class="spec-doc"><p><code>modify r f</code> is equivalent to <code>let* x = get r in set r (f x)</code>.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-exchange"><a href="#val-exchange" class="anchor"></a><code><span><span class="keyword">val</span> exchange : <span><span><span class="type-var">'a</span> <a href="../Loc/index.html#type-t">Loc.t</a></span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'a</span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'a</span> <a href="#type-t">t</a></span></span></code></div><div class="spec-doc"><p><code>exchange r v</code> is equivalent to <code>update r (fun _ -&gt; v)</code>.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-return"><a href="#val-return" class="anchor"></a><code><span><span class="keyword">val</span> return : <span><span class="type-var">'a</span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'a</span> <a href="#type-t">t</a></span></span></code></div><div class="spec-doc"><p><code>return v</code> is a transactional operation whose result is the value <code>v</code>.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-let*"><a href="#val-let*" class="anchor"></a><code><span><span class="keyword">val</span> let* : <span><span><span class="type-var">'a</span> <a href="#type-t">t</a></span> <span class="arrow">&#45;&gt;</span></span> <span><span>(<span><span class="type-var">'a</span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'b</span> <a href="#type-t">t</a></span>)</span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'b</span> <a href="#type-t">t</a></span></span></code></div><div class="spec-doc"><p><code>let* x = x_tx in to_y_tx x</code> is the sequential composition of the transaction <code>x_tx</code> with the transaction <code>to_y_tx x</code> computed from the result <code>x</code> of <code>x_tx</code>.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-and*"><a href="#val-and*" class="anchor"></a><code><span><span class="keyword">val</span> and* : <span><span><span class="type-var">'a</span> <a href="#type-t">t</a></span> <span class="arrow">&#45;&gt;</span></span> <span><span><span class="type-var">'b</span> <a href="#type-t">t</a></span> <span class="arrow">&#45;&gt;</span></span> <span><span>(<span class="type-var">'a</span> * <span class="type-var">'b</span>)</span> <a href="#type-t">t</a></span></span></code></div><div class="spec-doc"><p><code>( and* ) x_tx tx_y</code> is a transaction that performs both the transaction <code>x_tx</code> and the transaction <code>tx_y</code> and returns a pair of their results.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-let+"><a href="#val-let+" class="anchor"></a><code><span><span class="keyword">val</span> let+ : <span><span><span class="type-var">'a</span> <a href="#type-t">t</a></span> <span class="arrow">&#45;&gt;</span></span> <span><span>(<span><span class="type-var">'a</span> <span class="arrow">&#45;&gt;</span></span> <span class="type-var">'b</span>)</span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'b</span> <a href="#type-t">t</a></span></span></code></div><div class="spec-doc"><p><code>let+ x = tx in fn x</code> is equivalent to <code>let* x = tx in return (fn x)</code>.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-and+"><a href="#val-and+" class="anchor"></a><code><span><span class="keyword">val</span> and+ : <span><span><span class="type-var">'a</span> <a href="#type-t">t</a></span> <span class="arrow">&#45;&gt;</span></span> <span><span><span class="type-var">'b</span> <a href="#type-t">t</a></span> <span class="arrow">&#45;&gt;</span></span> <span><span>(<span class="type-var">'a</span> * <span class="type-var">'b</span>)</span> <a href="#type-t">t</a></span></span></code></div><div class="spec-doc"><p><code>and+</code> is a synonym for <a href="#val-and*"><code>and*</code></a> for use with <a href="#val-let+"><code>let+</code></a>.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-(&gt;&gt;)"><a href="#val-(&gt;&gt;)" class="anchor"></a><code><span><span class="keyword">val</span> (&gt;&gt;) : <span><span><span class="type-var">'ignore</span> <a href="#type-t">t</a></span> <span class="arrow">&#45;&gt;</span></span> <span><span><span class="type-var">'a</span> <a href="#type-t">t</a></span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'a</span> <a href="#type-t">t</a></span></span></code></div><div class="spec-doc"><p><code>u_tx &gt;&gt; x_tx</code> is equivalent to <code>let* _ = u_tx in x_tx</code>.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-(&gt;&gt;.)"><a href="#val-(&gt;&gt;.)" class="anchor"></a><code><span><span class="keyword">val</span> (&gt;&gt;.) : <span><span><span class="type-var">'ignore</span> <a href="#type-t">t</a></span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'a</span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'a</span> <a href="#type-t">t</a></span></span></code></div><div class="spec-doc"><p><code>u_tx &gt;&gt;. x</code> is equivalent to <code>let+ _ = u_tx in x</code>.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-(&gt;&gt;=)"><a href="#val-(&gt;&gt;=)" class="anchor"></a><code><span><span class="keyword">val</span> (&gt;&gt;=) : <span><span><span class="type-var">'a</span> <a href="#type-t">t</a></span> <span class="arrow">&#45;&gt;</span></span> <span><span>(<span><span class="type-var">'a</span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'b</span> <a href="#type-t">t</a></span>)</span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'b</span> <a href="#type-t">t</a></span></span></code></div><div class="spec-doc"><p><code>&gt;&gt;=</code> is a synonym for <a href="#val-let*"><code>let*</code></a>.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-map"><a href="#val-map" class="anchor"></a><code><span><span class="keyword">val</span> map : <span><span>(<span><span class="type-var">'a</span> <span class="arrow">&#45;&gt;</span></span> <span class="type-var">'b</span>)</span> <span class="arrow">&#45;&gt;</span></span> <span><span><span class="type-var">'a</span> <a href="#type-t">t</a></span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'b</span> <a href="#type-t">t</a></span></span></code></div><div class="spec-doc"><p><code>map xy x_tx</code> is equivalent to <code>let+ x = x_tx in xy x</code>.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-delay"><a href="#val-delay" class="anchor"></a><code><span><span class="keyword">val</span> delay : <span><span>(<span>unit <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'a</span> <a href="#type-t">t</a></span>)</span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'a</span> <a href="#type-t">t</a></span></span></code></div><div class="spec-doc"><p><code>delay to_tx</code> is equivalent to <code>let* () = return () in to_tx ()</code></p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-try_in"><a href="#val-try_in" class="anchor"></a><code><span><span class="keyword">val</span> try_in : <span><span>(<span>exn <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'b</span> <a href="#type-t">t</a></span>)</span> <span class="arrow">&#45;&gt;</span></span> <span><span>(<span><span class="type-var">'a</span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'b</span> <a href="#type-t">t</a></span>)</span> <span class="arrow">&#45;&gt;</span></span> <span><span><span class="type-var">'a</span> <a href="#type-t">t</a></span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'b</span> <a href="#type-t">t</a></span></span></code></div><div class="spec-doc"><p><code>try_in e_to_y_tx x_to_y_tx x_tx</code> is for handling exceptions during the access log recording phase of running a transaction. In case the transaction <code>x_tx</code> raises during the first phase, the accesses from <code>x_tx</code> are forgotten.</p><p><code>try_in e_to_y_tx x_to_y_tx x_tx</code> is the equivalent of</p><pre class="language-ocaml"><code>match run_phase_1 x_tx with
| x -&gt; run_phase_1 (x_to_y_tx x)
| exception e -&gt; run_phase_1 (e_to_y_tx e)</code></pre><p>for transactions.</p><p>Note that the order of parameters is chosen with the following style in mind:</p><pre class="language-ocaml"><code>transaction
|&gt; try_in (fun exn -&gt; (* handle failure *)) @@ fun value -&gt;
   (* continue successfully *)</code></pre></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-(&lt;|&gt;)"><a href="#val-(&lt;|&gt;)" class="anchor"></a><code><span><span class="keyword">val</span> (&lt;|&gt;) : <span><span><span class="type-var">'a</span> <a href="#type-t">t</a></span> <span class="arrow">&#45;&gt;</span></span> <span><span><span class="type-var">'a</span> <a href="#type-t">t</a></span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'a</span> <a href="#type-t">t</a></span></span></code></div><div class="spec-doc"><p><code>l_tx &lt;|&gt; r_tx</code> is a left-biased choice between the two transactions <code>l_tx</code> and <code>r_tx</code>.</p><p>If the <code>l_tx</code> transaction successfully produces a log of operations in the first phase of <a href="#val-attempt"><code>attempt</code></a>, then those are attempted in the second phase. On the other hand, if the <code>l_tx</code> transaction raises <code>Exit</code>, then the choice acts like <code>r_tx</code>.</p><p>For example, <code>(set x_loc x &gt;&gt; forget) &lt;|&gt; r_tx</code> is equivalent to <code>r_tx</code> meaning that the <code>set x_loc x</code> access will not be part of the operations attempted in the second phase of a transaction.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-forget"><a href="#val-forget" class="anchor"></a><code><span><span class="keyword">val</span> forget : <span><span class="type-var">'a</span> <a href="#type-t">t</a></span></span></code></div><div class="spec-doc"><p><code>forget</code> is equivalent to <code>delay (fun () -&gt; raise Exit)</code>.</p><p>The name <code>forget</code> was chosen to give the idea that this causes the transaction to forget any accesses made during the forgotten part of a transaction.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-attempt"><a href="#val-attempt" class="anchor"></a><code><span><span class="keyword">val</span> attempt : <span><span><span class="type-var">'a</span> <a href="#type-t">t</a></span> <span class="arrow">&#45;&gt;</span></span> <span class="type-var">'a</span></span></code></div><div class="spec-doc"><p><code>attempt tx</code> attempts to atomically perform the given transaction over shared memory locations. Either raises <code>Exit</code> on failure to commit the transaction or returns the result of the transaction.</p></div></div><div class="odoc-spec"><div class="spec value anchored" id="val-commit"><a href="#val-commit" class="anchor"></a><code><span><span class="keyword">val</span> commit : <span>?backoff:<a href="../Backoff/index.html#type-t">Backoff.t</a> <span class="arrow">&#45;&gt;</span></span> <span><span><span class="type-var">'a</span> <a href="#type-t">t</a></span> <span class="arrow">&#45;&gt;</span></span> <span class="type-var">'a</span></span></code></div><div class="spec-doc"><p><code>commit tx</code> repeats <code>attempt tx</code> until it does not raise <code>Exit</code> and then either returns or raises whatever <code>attempt tx</code> returned or raised.</p><p>Note that, aside from using exponential backoff to reduce contention, the transaction mechanism has no way to intelligently wait until shared memory locations are modified by other domains.</p></div></div></div></body></html>